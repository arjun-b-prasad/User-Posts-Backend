npm init -y
npm install --save express dotenv pg pg-hstore sequelize sequelize-cli
npm install -D ts-node @types/node ts-node-dev
    -create a index.ts file
tsc --init
    -change in scripts "dev" : "tsnd --respawn index.ts"
npx sequelize-cli init 
    -clear /models & create index.ts (specify the db info) and create User & Post Models.

mkdir routes
    -create auth.routes.ts file (create a router for this);
    -link this to main index.ts and test with postman.
    -[instead of creating many app.use() for every routes in index.ts, make use of a foreach loop]

mkdir controllers(route functions), services(databse query and business logic), dtos(data-transfer-object for login api - user&email validate), interface(variables and function's types define)
    -cd interface & create routes.interface.ts
    -create a interface type (Route) for AuthRoutes like path and router.
    -AuthRoutes should implement this Route interface.
    -cd routes and change the auth.routes.ts file's router.get to router.post logic. 
    -cd controllers & create auth.controller.ts and create a class for signup logic.

npm install class-validator
    -cd dtos create a dtos class SignupDTO in (auth.dto.ts).
    -when setting up @IsEmail(),@IsString() and @Length(8) from class-validator if ts throws error goto tsconfig.json
        - "target": "ES5" or "ES2016", 
          "experimentalDecorators": true,
          "emitDecoratorMetadata": true, 
          "strictPropertyInitialization": true --> false.    
    -import SignupDTO to auth.controller.ts 
    -since POST method works with data in {body} we must use userData: SignupDTO = req.body.
    -cd services and create auth.service.ts
    -in auth.service.ts create a AuthService class, import SignupDTO here and create public async signup(data:SignupDTO) that returns Promise<any>.
    -import {User} from models/user, create a const user = await User.findOne({where: {email:data.email}}).
    -This is used to check if a user already exists or not with same email.
    
npm install bcrypt 
    -countinue in auth.service.ts to make a hashed password - import bcrypt from 'bcrypt.
    -bcrypt.hash(data.pass,10) here 10 indicated no of rounds for hashing.
    -const newUser = await User.create({
          email: data.email,
          name: data.name,
          pass: newPass
      }); for creating a new user.
    -this pops new erros since User model has optional values like id,verifed that has to be autogenerated.
    -goto models/User.ts also import {Optional} from 'sequelize' and add - export interface UserInput extends Optional<userInterface| 'id' | 'isVerified'>{}
    -modify {export class User extends Model<userInterface> implements userInterface} to export class User extends Model<userInterface,UserInput> implements userInterface
    -goto auth.service.ts, add return newUser for the Promise and add return type as Promise<userInterface>.
    -goto auth.controller.ts and import AuthService, inside the class create - public newAuthService = new AuthService()
    -add inside try { const data = await this.newAuthService.signup(userData); res.status(200).json({message:'User has been created sucessfully!',data}); }
    -add inside catch(err:any) { res.status(err.status??500).json({message:err.message??'Something went wrong...'}) }
    -goto auth.routes.ts add inside the class - public authController = new AuthController();
    -the this.router.post has to be --> this.router.post(`${this.path}/sign-up`, this.authController.signup)
    -goto index.ts add middleware app.use(express.json()); app.use(express.urlencoded({ extended : false })); for parsing the body.

npm run dev
    -open POSTMAN localhost:3000/api/auth/sign-up [POST], Body -> Raw -> JSON
    -{
        "email" : "test@gmail.com",
        "pass" : "123@abc",
        "name" : "John Doe"
     }

npm install class-transformer
mkdir middlewares
    -create validation.middleware.ts import Validate, ValidationError from class-validator and plainToInstance from class-transformer(used to convert plain obj to class obj).
    -create const validationMiddleware = (type:any,value:'body' | 'params' | 'query' = 'body' ) => { // = 'body' means default value is body.
        return async(req,res,next)=>{
            const errors = await validate(plainToInstance(type,req[value]),{ skipMissingProperties : false }); // skipMissingProperties will validate empty fields.
            if(errors.length > 0) {
                const message = errors.map((error:ValidationError)=>
                    Object.value(error.constraints!)).join(', '); // ! in error.constraints! is used to remove ts errors.
                res.status(400).json(message)
            }
            else // IF NO ERRORS pass to next middleware.
                next();
        };
    };
    -import validationMiddleware, SignupDTO to auth.routes.ts
    -change the post method to this.router.post(`${this.path}/sign-up`, validationMiddleware(SignupDTO, 'body'), this.authController.signup)


cd routes
    -in auth.routes.ts add a login route by copy and modify the sign-up route, also change DTO to LoginDTO and controller.login.
    -goto auth.dto.ts copy and modify the SignupDTO as LoginDTO and remove name field.
    -goto auth.controller.ts copy and modify the signup, rename components to LoginDTO and newAuthService.signup to login in and change the message.
    -goto auth.service.ts copy and modify the signup, data: LoginDTO and Promise<any> modify to check mismatch of (!user)
        if(!user)
            throw {status:400, message: "User not exist!"};
    -to check if password is mismatch we compare the stored encrypted pass and user input pass
        const isMatch = await bcrypt.compare(data.pass,user.pass);
        if(!isMatch)
            throw {status:400, message: "Wrong Password"};

    
npm install jsonwebtoken
    -import jwt from jsonwebtoken in auth.service.ts
    -add in login method 
        const payload = {
            id: user.id,
            name: user.name,
            email: user.email,
            isVerified: user.isVerified
        }
        const token = jwt.sign( payload, process.env.JWT_SECRET, { expiresIn : 86400 }) // process.env.JWT_SECRET = jwt-secret [environment variable]
        return { user:payload, token: `Bearer ${token}`}
        
    -goto auth.routes.ts and import {LoginDTO} also. To change Promise<any> in auth.service.ts we must create a new Interface.
    -goto auth.interface.ts 
        export interface LoginInterface {
            user: UserData;
            token: string;
        }
        export interface UserData {
            id: number;
            email: string;
            name: string;
            isVerified: boolean;
        }
    -goto auth.service.ts change Promise<any> to Promise<LoginInterface>
    -!!! We had made a mistake when creating the user as we send the password back with response. So to rectify it we modify auth.service.ts.
         const result = {
            id: newUser.id
            name: newUser.name,
            email: newUser.email,
            isVerified: newUser.isVerified
        }
        return result;
    -also in auth.service.ts change the signup Promise<User> to Promise<UserData>
